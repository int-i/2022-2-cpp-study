#include <iostream>
#include <stack>

#include "Stack.h"

using std::cin;
using std::cout;
using std::endl;

using std::string;

using std::stack;

// 자료구조 - 스택
// 스택은 LIFO(Last In First Out) 구조의 자료구조로,
// 가장 먼저 넣은 데이터가 가장 마지막에 나오는 구조를 가지고 있다.
// (후입선출 혹은 선입후출이라고도 한다.)
// 이 방향 이외에는 값을 넣을 수 없으며,
// 스택에서 값을 꺼내올 때에도 가장 마지막에 넣은 값 부터 꺼내올 수 있다.
// 
// 스택의 연산(메서드)로는 top, push, pop 등이 있는데
// 해당 대표 연산 3가지는 각각 아래와 같은 동작을 한다.
// top: 스택의 가장 위에 있는 값을 반환하는 연산(값을 제거하는게 아니다!)
// push: 스택의 top 위치에 집어넣는 연산
// pop: 스택의 top 위치에서 값을 빼내는 연산
// 
// 스택의 모양은 프링글스 통처럼 생겼다고 생각하면 편한데,
// 프링글스 통에 감자칩을 집어넣는다고 가정을 하면,
// 가장 먼저 넣은 감자칩이 가장 마지막에 나온다는 것을 알 수가 있다.
// 이처럼 스택도 가장 먼저 넣은 값이 가장 마지막에 나오게 되는데,
// 이런 어찌보면 불편해보이는 구조적 특성으로 인해,
// 아래와 같은 분야에서 활용이 가능하다.
//
// 실행 취소 (undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
// 웹 브라우저 방문기록 (뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
// 수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
// 
// 스택을 활용한 대표적인 세 가지 예시인데, 이 예시 중 하나만 살펴보자면,
// 예를 들어 실행 취소의 경우
// 파일 클릭 - 3번째 줄 변경 - 5번째 줄 변경
// 이런 과정을 진행했다고 가정하자.(github에 올라간 자료구조 설명용.pptx 5페이지 참고)
// 그럼 이 경우 파일 클릭이 가장 밑에 들어갈 것이고,
// 그 위에 3번째 줄 변경, 그 위에 5번째 줄 변경이 올라갈 것이다.
// 여기서 컨트롤 z를 눌러 하나씩 실행 취소를 하게 된다면,
// 당연히 5번째 줄 변경 내용이 취소가 될 것이고,
// 그 다음 3번째 줄 변경 내용이 취소,
// 마지막으로, 파일을 클릭했던 시점으로 돌아오게 될 것이다.
// 
// 이런식으로 스택은 다양한 분야에서 활용이 되어진다.
// 
// 참고로 이 스택이 비어있는 상황에서 요소를 꺼내오려고(pop) 하는 경우,
// 발생하는 오류를 stack underflow라고 부르며,
// 스택이 꽉 차있는 상황에 요소를 더 집어넣으려고(push) 하는 경우,
// 발생하는 오류를 stack overflow라고 부른다.
// 
// 스택에 대한 간단한 설명은 여기까지 하고, 코드를 살펴보기 위해 stack.h로 넘어가자.
//  


int main() {
	Stack<int> stack;
	stack.Push(1);
	stack.Push(2);
	stack.Push(3);
	stack.Push(4);
	stack.Push(5);

	cout << stack.Top() << endl;


	cout << stack.Pop() << endl;
	cout << stack.Pop() << endl;
	cout << stack.Pop() << endl;
	cout << stack.Pop() << endl;
	cout << stack.Pop() << endl;
	cout << stack.Pop() << endl << endl;
	return 0;
}
