#include <iostream>
using std::cin;
using std::cout;
using std::endl;

// 연산자 오버로딩
// 함수 오버로딩, 메서드 오버로딩, 생성자 오버로딩 처럼 연산자도 오버로딩이 가능!
// 오버로딩은 함수명이 같지만 매개변수의 자료형이나 수가 다른 함수의 선언을 허용하여
// 여러 기능을 가진 함수를 만드는 것을 말한다.
// 그렇다면 이것을 연산자 오버로딩에 대입해보면,
// 연산자 오버로딩은 같은 모양의 연산자이지만 다른 기능을 수행하게끔 하는 것을 말하게 된다.
// 
// 흔히들 오해를 하는 부분이지만, 연산자 오버로딩은 메서드처럼 클래스에 종속되게만 만들 수 있는게 아님!
// 전역함수로서 연산자를 오버로딩하여 해당 클래스의 객체를 피연산자로서 활용할 수도 있다.
// 물론 friend 키워드를 사용해 클래스 안에도 넣어줄 수 있음

// 연산자 오버로딩의 주의점
// 1. 본래의 의도를 벗어나지 않아야 한다.
//  - 예를 들어 +인데 더하지 않고 빼버리는 경우...
// 
// 2. 연산자의 우선순위와 결합성은 바뀌지 않는다.
//  - 뭔짓을 해도 +연산자는 =연산자보다 우선순위가 빠르다
// 
// 3. 매개변수의 디폴트 값 설정이 불가능하다.
//  - void foo(int a = 10); 이런것 처럼 일반적인 함수는 매개변수에 디폴트 값을 넣을 수 있지만,
//    연산자 오버로딩에선 안된다.
// 
// 4. 연산자의 순수 기능은 뺏을 수는 없다.
//  - +인데 두 값을 더하는 기능을 없애버릴 수 없다는 뜻


// 연산자 오버로딩 예제

// 복소수는 실수부와 허수부로 이루어져있으며,
// 3 + 5i처럼 (실수부) + (허수부)i로 표현할 수 있다.
// 간단하게 할거라 극좌표는 여기서 다루지 않음
class 복소수 {
public:
	복소수()
		: 실수부{ }, 허수부{ } {}

	복소수(int r, int i)
		: 실수부{ r }, 허수부{ i } {}


	void display() {
		if (허수부 < 0)
			cout << 실수부 << 허수부 << 'i' << endl;
		else
			cout << 실수부 << '+' << 허수부 << 'i' << endl;
	}

	int get_실수부() {
		return 실수부;
	}

	int get_허수부() {
		return 허수부;
	}

	// a + b == a.operator+(b);

	// 반환값이 복소수인 + 연산자
	// 여기서는 멤버함수를 이용한 오버로딩을 함
	복소수 operator+(복소수 c) {
		// 익명 복소수 객체를 생성해주는데,
		// 실수부는 왼쪽 객체의 실수부, 오른쪽 객체의 실수부를 서로 합친 값을 넣어주고,
		// 허수부는 왼쪽 객체의 허수부, 오른쪽 객체의 허수부를 서로 합친 값을 넣어준다.
		return 복소수{ 실수부 + c.실수부, 허수부 + c.허수부 };
	}

	// 반환값이 복소수인 - 연산자
	//복소수 operator-(복소수 c) {
	//	// 익명 복소수 객체를 생성해주는데,
	//	// 실수부는 왼쪽 객체의 실수부, 오른쪽 객체의 실수부를 서로 빼준 값을 넣어주고,
	//	// 허수부는 왼쪽 객체의 허수부, 오른쪽 객체의 허수부를 서로 빼준 값을 넣어준다.
	//	return 복소수{ 실수부 - c.실수부, 허수부 - c.허수부 };
	//}

	// 여기서는 friend 키워드를 사용해 전역함수를 이용한 오버로딩을 함.
	복소수 friend operator-(복소수 c1, 복소수 c2) {
		// 익명 복소수 객체를 생성해주는데,
		// 실수부는 왼쪽 객체의 실수부, 오른쪽 객체의 실수부를 서로 빼준 값을 넣어주고,
		// 허수부는 왼쪽 객체의 허수부, 오른쪽 객체의 허수부를 서로 빼준 값을 넣어준다.
		return 복소수{ c1.실수부 - c2.실수부, c1.허수부 - c2.허수부 };
	}

	// 복소수의 곱셈은
	// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
	복소수 operator*(복소수 c) {
		return 복소수{ (실수부 * c.실수부) - (허수부 * c.허수부),
			(실수부 * c.허수부) + (허수부 * c.실수부) };
	}

	// 위의 경우는 사실 복소수끼리 계산하는 경우라 교환 법칙이 항상 성립한다.
	// * 교환 법칙: A + B == B + A 가 성립 할 때 교환법칙이 성립한다 한다.
	// 아래 예시는 교환법칙을 허용하기 위해 전역함수를 이용한 연산자 오버로딩을 하였다.

	// 복소수가 *연산자 왼쪽에 오고 실수가 *연산자 오른쪽에 올 때
	복소수 friend operator*(복소수 c, int i) {
		return 복소수{ (i * c.실수부) - (0 * c.허수부),
			(i * c.허수부) + (0 * c.실수부) };
	}

private:
	int 실수부;
	int 허수부;
};

// 실수가 *연산자 왼쪽에 오고 복소수가 *연산자 오른쪽에 올 때
// 이런식으로 friend 키워드 없이 클래스 바깥에서 그냥 연산자 오버로딩을 진행해도 된다.
// 
// firend 키워드는 특정 클래스 또는 함수에게 해당 클래스의 비공개된 멤버를 모두 공개하게하는 키워드이기 때문에
// get함수가 없어도 실수부, 허수부라는 멤버변수에 접근 할 수 있었지만,
// 이런식으로 아예 전역 위치에서 연산자 오버로딩을 진행한다면,
// 반드시 get함수를 사용해 멤버변수에 접근해야 한다.
복소수 operator*(int i, 복소수 c) {
	return 복소수{ (i * c.get_실수부()) - (0 * c.get_허수부()),
		(i * c.get_허수부()) + (0 * c.get_실수부()) };
}

int main() {
	복소수 c1{ 2, 1 };
	복소수 c2{ 5, 3 };

	복소수 c3{ };
	//c3 = operator-(c1, c2);
	c3 = c1 - c2; // == c1.operator+(c2);
	//c3 = c1.operator-(c2);


	복소수 c4{ c2 * c3 };

	//복소수 c5{ 3 * c2 };
	복소수 c5{ operator*(3, c2) };

	복소수 c6{ c3 * 7 };

	c1.display();
	c2.display();
	c3.display();
	c4.display();
	c5.display();
	c6.display();

	return 0;
}
