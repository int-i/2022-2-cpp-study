#include <iostream>
#include <list>

using std::cin;
using std::cout;
using std::endl;

using std::string;

using std::list;

// 자료구조 - 자료구조와 템플릿
// C++은 STL이라는 템플릿 라이브러리가 있어서 아무 자료형이나 넣을 수 있는 자료구조를 선언할 수 있다.
// ex)
list<int> li{ }; // int를 요소의 자료형으로 가지는 리스트
list<double> li2{ }; // double을 요소의 자료형으로 가지는 리스트
list<string> li3{ }; // string을 요소의 자료형으로 가지는 리스트
list<list<bool>> li4{ }; // list<bool>을 요소의 자료형으로 가지는 리스트
// 위 처럼 템플릿 인자는 진짜 아무거나 다 넣을 수 있다.
// int나 double 같은 원시 자료형부터, string 같은 사용자 정의 자료형이나,
// 심지어는 같은 list까지도, 전부 다 넣을 수 있다.
// 
// 이게 되는 이유는 템플릿 이라는 놈 때문인데, 템플릿은 템플릿 인자로 들어온 값을 기준으로
// 컴파일 타임에, 해당 값에 맞는 코드를 새로 만들게 된다.
// 이해가 잘 안된다면 아래의 코드를 보자.
// 
// ex)
template <typename T>
T add(T a, T b) {
	return a + b;
}
// 자, 위와 같은 코드가 있다고 가정하자.
// 우선 가장 첫줄에 template 이라는 키워드와, 그 뒤에 <typename T>가 오는데,
// 일단 당연히 template 이라는 키워드는 템플릿 코드를 구성하기 위한 키워드이고,
// <typename T> 이 부분은 템플릿 매개변수가 오는 부분이다.
// 함수에서 인자를 넣으면 매개변수가 그 인자의 값을 받는다는 것은 기억할텐데,
// 마찬가지로 템플릿에서도, 템플릿 코드를 호출 할 때, 템플릿 인자를 넣게 되면,
// 템플릿 매개변수가 해당 인자를 받게 된다.
// 이때 템플릿 인자는 기본적으로 자료형을 넘길 수 있다.
// 
// 템플릿 인자를 통해 넘어온 자료형은 T라는 템플릿 매개변수가 받게 되는데,
// 예를 들어 넘어온 인자가 int다, 그러면 위의 함수는 아래처럼
// 
int add(int a, int b) {
	return a + b;
}
// 
// 원래 T 였던 부분이 전부 int로 바뀌게 된다.
// 
// 위처럼 함수에 템플릿을 붙이는 것을 함수 템플릿 이라 부른다.
// 
// 템플릿에 대한 기본적인 개념은 알았으니, 본격적으로 클래스 템플릿에 대해 알아보자.
// 클래스 템플릿이란, 이름 그대로 클래스에 템플릿이 붙은 것을 말한다.
// 예시를 들기 위해 지난번 진행했던 링크드 리스트를 템플릿화 시켜서 작성을 해보자.
// 
// ex)
template <typename T>
struct Node {
	T data;
	Node<T>* next;
};
// 
// 자 우선 노드부터 구조체 템플릿으로 만들어주었다.
// 저번에도 말했지만 클래스나 구조체나 기본 접근 지정자를 제외한 나머지 부분은 똑같기 때문에
// 구조체에도 템플릿을 씌울 수 있다.
// 
// 우선 저번과 비교해서 변수 data의 자료형이 int에서 T로 바뀐 것이 보이고,
// 다음 노드를 가리키는 Node 포인터가 Node<T> 포인터로 바뀐 것을 알 수가 있다.
// 
// 예를 들어 새 Node 객체를 만든다 가정했을 때,
// Node<int> node{ };
// 이런식으로 새 Node 객체를 하나 선언을 해주게 되면,
// 이 객체를 선언하면서 템플릿 인자로 넣어준, int가 템플릿 매개변수로 넘어가게 되면서,
// 위의 코드는 아래처럼 바뀌게 될 것 이다.
// 
//struct Node {
//	int data;
//	Node<int>* next;
//};
// 
// 여기서 next는 "int를 템플릿 인자값으로 받는 Node 객체"를 가리키는 포인터
// 
// 위처럼 T가 들어가있던 부분이 int로 바뀌게 되고, 우리가 이전에 만들었던 Node 구조체와 같은 역할을 하게 된다.
// 이때, 주의해야 될 점이 있는데, 이 모든 과정은 전부 컴파일 타임에 진행 된다.
// 컴파일 타임에, 컴파일러가 코드를 살펴보고, 템플릿 매개변수로 들어올 자료형을 다 확인해,
// 해당 자료형에 맞는 코드들(위처럼 int를 넣은 코드라든가 다른게 들어왔다면 다른 자료형에 맞는 코드)을 작성하게 된다.
// 
// 
// 이렇게 바뀌는 것은 클래스도 마찬가지로,
// 링크드 리스트 클래스를 예를 들면
// 
template <typename T>
class Linkedlist {
public:
	Linkedlist() : head{ }, tail{ }, size{ } { }

	// 리스트의 끝(back)에 노드를 집어넣는(push) 메서드
	void push_back(T data) {
		Node<T>* node{ new Node<T> }; // 리스트에 넣을 새 노드 동적 할당

		// 새 노드의 값 설정
		node->data = data;
		node->next = nullptr;

		if (head == nullptr) { // head가 비어있을 경우 == 리스트가 비어있는 경우
			// head 와 tail, 두 포인터 모두 새 노드를 가리키게 한다.
			head = node;
			tail = node;
		}
		else { // head가 비어있지 않은 경우 == 리스트가 비어있지 않은 경우
			// 기존의 tail 포인터가 가리키는 노드의 next 포인터가 nullptr에서 새 노드를 가리키게 하고,
			tail->next = node;
			// tail 포인터는 기존의 tail이 가리키던 노드의 다음 노드,
			// 즉 새 노드를 가리키게 한다.
			tail = tail->next;
		}

		++size; // 리스트에 노드가 추가되었으니, 리스트의 size를 1 증가시킨다.
	}

	// 리스트 안의 값을 출력하는 메서드
	void display() {
		if (head == nullptr)
			cout << "리스트가 비어있습니다!" << endl;

		Node<T>* ptr = head;

		while (ptr != nullptr) { // 리스트의 끝에 도달 할 때까지 반복
			cout << ptr->data;
			if (ptr->next != nullptr)
				cout << "->";
			ptr = ptr->next;
		}
		cout << endl;
	}

private:
	Node<T>* head;
	Node<T>* tail;
	int size;
};
// 
// 예시를 좀 간단하게 보기 위해서 메서드들을 좀 쳐냈다.
// 
// 자, 코드를 보면, 템플릿 자료형 T를 선언하고, 노드를 새로 선언하는 부분에 갖다가 쓴 것을 볼 수 있다.
// 그리고, 노드에 들어갈 데이터 역시 당연하지만 T 자료형으로 선언이 되어있다.
// 이런식으로 구현을 해두게 되면, 각 자료형마다 새 클래스를 만들 필요 없이,
// 들어오는 자료형에 맞춰 컴파일러가 알아서 코드를 새로 짜주게 된다.
// 
// 템플릿 관련해서 주의사항 하나 더,
// 템플릿은 컴파일 타임에 바인딩이 이뤄져야 되기 때문에,
// 함수 선언과 정의를 서로 다른 파일에 분리 할 수가 없다.
// 단, 꼼수 쓰면 가능하긴 함.
// 
// 그리고 코드 잘못짰을 때 디버깅하기가 너무 어렵다...
// 

int main() {
	Linkedlist<double> li{ };

	li.push_back(3.14);
	li.push_back(5.73);
	li.push_back(9.12);

	li.display();

	// 이런식으로 double 값이 들어간 리스트를 쉽게 만들 수 있다.

	return 0;
}
