#include <iostream>
using std::cin;
using std::cout;
using std::endl;

// 객체 지향 프로그래밍의 4요소
// 추상화, 캡슐화, 상속, 다형성
// 이 4가지 요소(사람에 따라 추상화는 빼고 3요소라 하는경우도 있음)는 객체 지향 프로그래밍을
// 지원하는 프로그래밍 언어라면 전부 제공하는 요소들이다.
// 
// 1. 추상화(Abstraction)
// 추상화란 복잡한 개념으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 의미한다.
// 
// 따라서 사실상 클래스 그 자체가 추상화를 구현한 것이라 볼 수 있다.
// 클래스란 현실의 개념을 컴퓨터가 이해할 수 있게끔 추상화 한 것을 의미하기 때문!
// 따라서 추상화를 제외하고 객체 지향 프로그래밍의 3요소라 부르는 경우도 많다.
// 
// ex) 현실의 개념인 "동물" 이란 개념을 추상화 하여 클래스로 구현하면,
class 동물 {
public:
	동물(int 다리개수, bool 아가미유무, bool 털유무) {
		this->다리개수 = 다리개수;
		this->아가미유무 = 아가미유무;
		this->털유무 = 털유무;
	}
	// 가상 함수: 자식 클래스에서 재정의(override) 될 수 있는 함수
	virtual void display() { cout << "동물 입니다." << endl; };

	int get_다리개수() { return 다리개수; }
private:
	int 다리개수;
	bool 아가미유무;
	bool 털유무;
};
// 위 처럼 동물이라는 개념을 컴퓨터가 이해할 수 있게끔 추상화 할 수 있다.


// 2. 캡슐화(Encapsulation)
// 변수와 함수를 하나의 단위로 묶는 것을 의미한다.
// 이를 번들링이라 부르는데 추상화와 마찬가지로 클래스 그 자체의 성질이라 볼 수 있다.
// 
// 클래스는 여러 변수들을 멤버 변수(필드)라는 이름으로 클래스에 담고
// 여러 함수들을 멤버 함수(메서드)라는 이름으로 클래스에 담는다.
// 
// 그리고 이 클래스를 통해 객체를 생성하면, 이 객체는 해당 클래스의 필드와 메서드들을 모두 갖고 있기 때문에
// 해당 객체에 .연산자 또는 ->연산자(포인터 객체일 때만)를 통해
// 해당 객체를 구성하는 클래스의 필드 또는 메서드에 쉽게 접근 할 수 있다.
// 
// ex)
// 동물 강아지{ 4, false, true };
// 강아지.get_다리개수();
// 
// 위처럼 여러 데이터를 한데 묶어놓는 것 그것을 캡슐화라 부른다.
// 이와 더불어서 정보 은닉이라는 개념도 있는데,
// 
// 정보 은닉은 캡슐화로부터 파생된 보조 개념으로,
// 프로그램의 세부 구현을 외부로 드러나지 않도록 감추는 것을 의미한다.
// 
// 대부분의 객체지향 언어에선 접근 지정자가 이를 위해서 제공 되는데,
// 
// public: 클래스의 외부에서 사용 가능하도록 노출시키는 것
// protected: 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것
// private: 클래스의 내부에서만 사용되며 외부로 노출되지 않음
// 
// 다른 객체 지향 언어 중 Python같은 경우에는 이 접근 지정자를 지원하지 않는다.
// 그래서 Python으로는 정보은닉은 구현하기가 좀 복잡한 편이다.


// 3. 상속(Inheritance)
// 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것이다.
// (부모 클래스의 필드와 메서드를 모두 물려받는 것)
// 기능(함수)의 일부분을 변경해야 할 경우 자식 클래스에서
// 상속받은 그 기능만을 수정해서 다시 정의(오버라이딩)하게 되는데,
// 이러한 작업을 '오버라이딩(overriding)'이라고 한다.
// 
// 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.
// 더 자세히 설명하는건 너무 길어지므로 추후 각 요소 상세 설명시간때 추가로 설명 예정
// ex)
class 포유류 : public 동물 {
public:
	포유류()
		// 멤버 이니셜라이저
		// 익명 동물 객체를 만들고 있다.
		// 이를 통해 동물 클래스의 생성자를 호출
		: 동물{ 4, false, true } { }

	// 부모 클래스에서 선언 된 가상함수는 자식클래스에서 오버라이딩이 가능함
	// 오버라이딩 된 메서드는 구분을 위해 override 키워드를 붙여주는게 보기 좋다
	void display() override { cout << "포유류 입니다." << endl; }; // 함수 오버라이딩
};

// 포유류 고양이{ };
// 고양이.get_다리개수();
// 4 반환
// 
// 상속받은 자식 클래스의 생성자는 멤버 초기화 리스트를 통해 부모 클래스의 생성자를 반드시 호출해야한다.
// is-a 관계가 바로 이런 관계이다. 포유류 is a 동물


// 4. 다형성(Polymorphism)
// 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것을 의미한다.
// 다형성은 여러가지 의미가 있는데, 보통 객체지향에서 말하는 다형성은 서브타입 다형성
// 기초 클래스 또는 어떠한 인터페이스를 구현하는 상위 클래스를 생성하고,
// 해당 클래스를 상속받는 다수의 하위 클래스들을 만들어,
// 상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조하게 하는 것
// 
// 이것도 마찬가지로 더 자세히 설명하는건 너무 길어지므로 추후 각 요소 상세 설명때 추가로 설명 예정
//
// ex)
class 파충류 : public 동물 {
public:
	파충류() : 동물{ 4, false, true } { }

	void display() override { cout << "파충류 입니다." << endl; };
};
// 동물* 동물포인터 = new 파충류{ };
// 동물포인터->display();
// 파충류 입니다 출력



// 오버라이딩
// 오버라이딩 상속받은 클래스의 메서드를 변경하는 것

// 오버로딩
// 상속과는 관계없이 이름이 같은 다른 함수가 있을 때
// 매개변수를 달리하여 다른 기능을 하게 하는 것

// 둘의 차이점
// 오버로딩은 무조건 매개변수가 달라야 하고
// 오버라이딩은 매개변수가 동일해도 괜찮다.

int main() {
	// 변수의 초기화는 기본적으로 직접 초기화와 복사 초기화가 있는데,
	// C++11부터 유니폼 초기화가 도입되었다.
	// 자세한 내용은 https://heroine-day.tistory.com/20 를 참고하자.
	동물 문어(8, true, false); // 직접 초기화
	동물 강아지{ 4, false, true }; // 유니폼 초기화(직접 초기화 방식)
	동물 뱀 = { 0, false, false }; // 유니폼 초기화(복사 초기화 방식)


	cout << 문어.get_다리개수() << endl;
	cout << 강아지.get_다리개수() << endl;
	cout << 뱀.get_다리개수() << endl;
	

	// 포인터를 통한 동적 할당
	// 다형성에 대해 배울 때 진행 예정
	동물* 동물포인터 = new 파충류{ };
	동물포인터->display();

	return 0;
}
