#include <iostream>
using std::cin;
using std::cout;
using std::endl;

using std::string;

// 상속
// 상속은 객체 지향 프로그래밍 4요소 중 하나
// 어떤 두개의 클래스를 부모 클래스와 자식 클래스로 이어주는 역할
// 생물 분류 단계가 이와 유사하다 볼 수 있다.
// 
// 자식 클래스는 부모 클래스의 모든 내용을 상속받는다
// 상속 받은 자식 클래스에선 부모클래스의 메서드를 오버라이딩 할 수 있음.
// C++ 기준으로 하나의 자식 클래스는 여러개의 부모클래스를 상속받을 수 있음
// 단, 죽음의 다이아몬드라 불리는 고착상태에 빠질 수 있기 때문에 권장되지 않음
// 이를 해결하기 위해 트레이트(traits)나 믹스인(mixin) 등의 기술이 사용 되기도
//
// 상속을 한 클래스와 상속을 받은 클래스 사이의 관계는 is-a 관계라고 한다.
// 예를 들어 포유류 is a 동물(포유류는 동물이다)
//
// 만약 클래스나 상속을 쓰지 않았다면, 사소한 수정 사항이라도 발생할 경우
// 모든 객체의 코드를 일일이 찾아다니며 수정을 해야 하지만,
// 상속을 쓰면 그냥 상속 받은 클래스에 새로운 변수를 하나 추가하거나,
// 재정의(오버라이딩) 같은 기능을 이용해서 입맛에 맞게 바꿔줄 수도 있다.


// 부모 클래스
class 동물 {
public:
	동물()
		// 멤버 이니셜라이저
		// 멤버 이니셜라이저는 생성자가 호출되기 전에 멤버를 초기화한다.
		// 
		// 반드시 멤버 이니셜라이저로 초기화해야 되는 것은
		// 상수 멤버, 레퍼런스 멤버, 멤버의 생성자를 호출해야 될 때,
		// 부모의 생성자를 호출해야 될 때
		: 다리_개수{ }, 털_유무{ }, 아가미_유무{ }, 날개_유무{ }, 서식지{ }
	{ }


	// 위와 동일한 생성자지만 멤버 이니셜라이저를 쓰지 않고 생성자 본문에서
	// 멤버들을 초기화 할 수 있다.
	// 그러나 이 경우 직접 초기화를 할 수 없고 복사 초기화만 가능하다.
	// 위의 초기화 방식은 엄밀히는 직접 초기화 방식의 유니폼 초기화,
	// 아래의 초기화 방식은 복사 초기화 방식의 유니폼 초기화
	// 두 방식에는 기본적으로 차이가 없지만 직접 초기화가 좀 더 빠르다
	// 다만 이 내용은 이거 하나만으로도 한 시간을 다 쓰기 때문에
	// 나중에 따로 강의 예정
	/*동물() {
		다리_개수 = { };
		털_유무 = { };
		아가미_유무 = { };
		날개_유무 = { };
		서식지 = { };
	}*/

	// 기본 생성자를 오버로딩 한 생성자
	동물(int 다리_개수, bool 털_유무, bool 아가미_유무, bool 날개_유무, string 서식지)
		: 다리_개수{ 다리_개수 }, 털_유무{ 털_유무 },
		아가미_유무{ 아가미_유무 }, 날개_유무{ 날개_유무 }, 서식지{ 서식지 } { }

	//동물(int 다리_개수, bool 털_유무, bool 아가미_유무, bool 날개_유무, string 서식지) {
	//	this->다리_개수 = 다리_개수;
	//	this->털_유무 = 털_유무;
	//	this->아가미_유무 = 아가미_유무;
	//	this->날개_유무 = 날개_유무;
	//	this->서식지 = 서식지;
	//}


	void 특징() {
		cout << "동물의 특징: "
			<< "운동성이 있고, 세포호흡을 하며, 유성생식이 가능한 생물" << endl;
	}

private:
	int 다리_개수;
	bool 털_유무;
	bool 아가미_유무;
	bool 날개_유무;
	string 서식지;
};

class 포유류 : public 동물 {
public:
	포유류()
		// 이처럼 상속을 받은 경우 부모 클래스가 가지고 있는 멤버를
		// 초기화 해줘야 하기 때문에,
		// 멤버 이니셜라이저를 통해 익명의 부모 클래스의 객체를 생성하여,
		// 해당 멤버들을 초기화 해준다.
		: 동물{ 4, true, false, false, "땅" }, 울음소리{ } { }

	// 이처럼 부모 클래스의 특징 이라는 메서드를 상속받고,
	// 그것을 오버라이딩 해줄 수 있음
	//void 특징() {
	//	cout << "포유류의 특징: "
	//		<< "유선이 있어 새끼들에게 젖을 먹이며 키우는 것이 특징" << endl;
	//}


private:
	string 울음소리;
};


int main() {
	동물 동물1{ };

	포유류 포유류1{ };


	동물1.특징();

	포유류1.특징();

	return 0;
}

